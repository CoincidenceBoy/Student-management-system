#### GIT	

GIT是用于跟踪在任何一组的改变软件文件，通常用于协调之间工作程序员协作开发源代码中的软件开发。其目标包括速度，数据完整性以及对分布式非线性工作流（在不同系统上运行的数千个并行分支）的支持。

Git由Linus Torvalds于2005年创建，用于Linux内核的开发，其他内核开发人员也为Git的初始开发做出了贡献。自2005年以来，Junio Hamano一直是核心维护者。与大多数其他分布式版本控制系统一样，并且与大多数客户端服务器系统不同，每台计算机上的每个Git目录都是具有完整历史记录和完整版本跟踪功能的完整存储库，而与网络访问或中央服务器无关。 Git是免费的，并且开源软件在GNU通用公共许可证版本。

#### 特性

Git的设计综合了Torvalds在Linux上维护大型分布式开发项目的经验，以及他对从同一项目获得的文件系统性能的深入了解以及迫切需要在短期内生产工作系统的综合。这些影响导致以下实现选择：

- 大力支持非线性发展
  Git支持快速分支和合并，并包括用于可视化和导航非线性开发历史的特定工具。在Git中，一个核心假设是，变更将被写入的频率要比写入的频率高，因为它会被传递给不同的审阅者。在Git中，分支非常轻巧：分支只是对一个提交的引用。借助其父提交，可以构造完整的分支结构。
- 分布式开发
  像Darcs，BitKeeper，Mercurial，Bazaar和Monotone一样，Git为每个开发人员提供完整开发历史记录的本地副本，并将更改从一个这样的存储库复制到另一个存储库。这些更改将作为添加的开发分支导入，并且可以像本地开发的分支一样进行合并。
- 与现有系统和协议的兼容性
  可以通过超文本传输协议（HTTP），文件传输协议（FTP）或Git协议，通过普通套接字或安全外壳（ssh）来发布存储库。Git还具有CVS服务器仿真功能，可以使用现有的CVS客户端和IDE插件来访问Git存储库。Subversion仓库可以直接与git-svn一起使用。
- 高效处理大型项目
  Torvalds将Git描述为非常快速且可扩展的工具，并且Mozilla [44]进行的性能测试表明，它比某些版本控制系统快一个数量级。从本地存储的存储库中获取版本历史记录的速度可能比从远程服务器中获取版本历史记录的速度快一百倍。
- 历史的密码认证
  Git历史记录的存储方式使得特定版本的ID（以Git术语表示的提交）取决于导致该提交的完整开发历史记录。一旦发布，就无法在不引起注意的情况下更改旧版本。结构类似于Merkle树，但在节点和叶子处添加了数据。（Mercurial和Monotone也具有此属性。）
- 基于工具包的设计
  Git被设计为一组用C语言编写的程序以及一些shell脚本，这些脚本为这些程序提供了包装。[47]尽管自那时以来，为了提高速度和可移植性，这些脚本中的大多数都已用C重写，但设计仍然存在，并且很容易将组件链接在一起。
- 可插拔合并策略
  作为其工具箱设计的一部分，Git具有定义完善的不完整合并模型，并且它具有多种算法来完成合并，最终告知用户无法自动完成合并，并且需要手动编辑。
- 垃圾堆积直到收集
  中止操作或撤消更改将在数据库中留下无用的悬空对象。这些通常只是所需对象不断增长的历史的一小部分。当在存储库中创建了足够的松散对象时，Git将自动执行垃圾收集。垃圾回收可以使用显式调用git gc。
- 定期显式对象打包
  Git将每个新创建的对象存储为单独的文件。尽管单独压缩，但这会占用大量空间并且效率低下。这是通过使用包来解决的，这些包将大量相互之间经过delta压缩的对象存储在一个称为packfile的文件（或网络字节流）中。使用启发式压缩包具有相同名称的文件可能很相似，而不必依赖于此是否正确。为每个打包文件创建一个对应的索引文件，告诉每个对象在打包文件中的偏移量。新创建的对象（具有新添加的历史记录）仍存储为单个对象，需要定期重新包装以保持空间效率。打包存储库的过程可能在计算上非常昂贵。通过允许对象以松散但快速生成的格式存在于存储库中，Git允许将代价高昂的打包操作推迟到以后再进行，直到时间紧迫，例如工作日结束。Git会自动进行定期重新打包，但是也可以使用该git gc命令进行手动重新打包。为了数据完整性，packfile及其索引均具有SHA-1校验和，并且packfile的文件名还包含SHA-1校验和。要检查存储库的完整性，请运行git fsck命令。
- Git的另一个特性是它可以对文件的目录树进行快照。最早的用于跟踪源代码版本的系统，源代码控制系统（SCCS）和修订控制系统（RCS）对单个文件进行工作，并强调了从交错增量（SCCS）或增量编码（RCS）获得的空间节省。（大多数类似）版本。后来的版本控制系统维护了文件的这一概念，该文件在项目的多个版本中具有相同的标识。但是，托瓦尔兹拒绝了这个概念。因此，Git不会在源代码树下的任何级别上显式记录文件修订版本关系。

这些隐式修订关系具有一些重要的后果：

​		检查一个文件的更改历史记录要比整个项目花费更多。要获得影响给定文件的更改历史，Git必须遍历全局历史，然后确定每个更改是否修改了该文件。但是，这种检查历史记录的方法的确可以让Git以相同的效率生成单个历史记录，以显示对任意文件集的更改。例如，源树的子目录加上相关的全局头文件是很常见的情况。
​		重命名是隐式处理，而不是显式处理。CVS的一个普遍抱怨是，它使用文件名来标识其修订历史记录，因此，在不中断文件历史记录或重命名历史记录，从而使历史记录不准确的情况下，无法移动或重命名文件。大多数CVS后版本控制系统通过给文件赋予唯一的长期名称（类似于inode编号）来解决该问题，该名称可以重命名。Git没有记录这样的标识符，因此被认为是一种优势。有时会拆分或合并源代码文件，或者只是将其重命名为并将其记录为简单的重命名将冻结（不可变的）历史记录中发生的错误描述。Git通过在浏览快照历史记录时检测重命名而不是在创建快照时记录重命名来解决该问题。（简而言之，给定版本N中的文件，版本N  -1中具有相同名称的文件是其默认祖先。但是，当版本N  -1中没有同名文件时，Git搜索文件仅存在于版本N  -1中，并且与新文件非常相似。）但是，它确实需要更多的CPU每次查看历史记录时都需要进行大量的工作，并且提供了几种调整启发式方法的选项。这种机制并不总是有效的。有时，将同一提交中的更改重命名的文件读作删除旧文件并创建新文件。开发人员可以通过分别提交重命名和更改来解决此限制。

Git实施了几种合并策略；可以在合并时选择非默认策略：

- 解决：传统的三路合并算法。
- 递归：这是拉或合并一个分支时的默认设置，并且是三向合并算法的变体。
  当可以用于三路合并的公共祖先不止一个时，它将创建一个公共祖先的合并树，并将其用作三路合并的参考树。据报道，通过对来自Linux 2.6内核开发历史记录的先前合并提交进行的测试，可以减少合并冲突，而不会引起错误合并。同样，这可以检测和处理涉及重命名的合并。— 莱纳斯·托瓦尔兹
- 章鱼：合并两个以上的头时，这是默认设置。

